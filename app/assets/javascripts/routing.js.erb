/*
	osm.org routing interface
	
	See also:
	https://github.com/apmon/openstreetmap-website/tree/routing2
	https://github.com/apmon/openstreetmap-website/compare/routing2
	https://github.com/apmon/openstreetmap-website/blob/9755c3ae0a8d0684d43760f91dc864ff42d8477a/app/views/routing/start.js.erb

	*** draggable start/end markers
	*** translation (including all alerts and presentation)
	*** export GPX
	*** URL history (or do we consciously not want to support that?)

	*** add MapQuest engine
	*** add YOURS engine
	*** finish CloudMade engine
*/

var TURN_INSTRUCTIONS=["",
	"Continue on ",				// 1
	"Slight right onto ",		// 2
	"Turn right onto ",			// 3
	"Sharp right onto ",		// 4
	"U-turn along ",			// 5
	"Sharp left onto ",			// 6
	"Turn left onto ",			// 7
	"Slight left onto ",		// 8
	"(via point) ",				// 9
	"Follow ",					// 10
	"At roundabout take ",		// 11
	"Leave roundabout - ",		// 12
	"Stay on roundabout - ",	// 13
	"Start at end of ",			// 14
	"Reach destination",		// 15
	"Go against one-way on ",	// 16
	"End of one-way on "]		// 17

var ROUTING_POLYLINE={
	color: '#03f',
	opacity: 0.3,
	weight: 10
};


OSM.RoutingEngines={
	list: []
	// common functions and constants, e.g. OSRM parser, can go here
};

OSM.Routing=function(map,name,jqSearch) {
	var r={};
	r.map=map;				// Leaflet map
	r.name=name;			// global variable name of this instance (needed for JSONP)
	r.jqSearch=jqSearch;	// JQuery object for search panel

	r.route_from=null;
	r.route_to=null;
	r.viaPoints=[];
	r.polyline=null;
	r.chosenEngine=null;

	// Geocoding

	r.geocode=function(id,event) { var _this=this;
		var field=event.target;
		var v=event.target.value;
		// *** do something if v==''
		var querystring = '<%= NOMINATIM_URL %>search?q=' + encodeURIComponent(v) + '&format=json';
		// *** &accept-language=<%#= request.user_preferred_languages.join(',') %>
		// *** prefer current viewport
		$.getJSON(querystring, function(json) { _this._gotGeocode(json,field); });
	};
	
	r._gotGeocode=function(json,field) {
		if (json.length==0) {
			alert("Sorry, couldn't find that place."); 	// *** internationalise
			r[field.id]=null;
			return;
		}
		field.value=json[0].display_name;
		var lat=Number(json[0].lat), lon=Number(json[0].lon);
		r[field.id]=[lat,lon];
		// ** update markers
	};
	
	// Route-fetching UI

	r.requestRoute=function() {
		if (r.route_from && r.route_to) {
			r.chosenEngine.getRoute(true,[r.route_from,r.route_to]);
			// then, when the route has been fetched, it'll call the engine's gotRoute function
		}
	};

	// Take an array of Leaflet LatLngs and draw it as a polyline
	r.setPolyline=function(line) {
		if (r.polyline) map.removeLayer(r.polyline);
		r.polyline=L.polyline(line, ROUTING_POLYLINE).addTo(r.map);
		r.map.fitBounds(r.polyline.getBounds());
	};

	// Take an array of directions and write it out
	// (we use OSRM's route_instructions format)
	// *** translations?
	r.setItinerary=function(steps) {
		// Create base table
		$("#content").removeClass("overlay-sidebar");
		$('#sidebar_content').empty();
		var html='<h2><a class="geolink" href="#" onclick="$(~.close_directions~).click();return false;"><span class="icon close"></span></a>Directions</h2>'.replace(/~/g,"'");
		html+="<table id='turnbyturn' />";
		$('#sidebar_content').html(html);
		// Add each row
		var cumulative=0;
		for (var i=0; i<steps.length; i++) {
			var step=steps[i];
			var instCodes=step[0].split('-');
			// Assemble instruction text
			var instText="<b>"+(i+1)+".</b> ";
			instText+=TURN_INSTRUCTIONS[instCodes[0]];
			if (instCodes[1]) { instText+="exit "+instCodes[1]+" "; }
			if (instCodes[0]!=15) { instText+=step[1] ? "<b>"+step[1]+"</b>" : "(unnamed)"; }
			// Distance
			var dist=step[2];
			if (dist<5) { dist=""; }
			else if (dist<200) { dist=Math.round(dist/10)*10+"m"; }
			else if (dist<1500) { dist=Math.round(dist/100)*100+"m"; }
			else if (dist<5000) { dist=Math.round(dist/100)/10+"km"; }
			else { dist=Math.round(dist/1000)+"km"; }
			// Add to table
			var row=$("<tr class='turn'/>");
			row.append("<td class='direction i"+instCodes[0]+"'> ");
			row.append("<td class='instruction'>"+instText);
			row.append("<td class='distance'>"+dist);
			with ({num: i, dist: step[3]}) {
				row.on('click',function(e) { 
					r.clickTurn(num, r.polyline.getLatLngs()[dist]);
				});
			};
			$('#turnbyturn').append(row);
			cumulative+=step[2];
		}
	};
	r.clickTurn=function(num,latlng) {
		L.popup().setLatLng(latlng).setContent("<p>"+(num+1)+"</p>").openOn(r.map);
	};


	// Close all routing UI
	
	r.close=function() {
		$("#content").addClass("overlay-sidebar");
		if (r.polyline) map.removeLayer(r.polyline);
	};

	// Routing engine handling

	// Add all engines
	r.addEngines=function(list) {
		list.sort(function(a,b) { return a.name>b.name; });
		r.engines=list;
		var select=r.jqSearch.find('select.routing_engines');
		for (var i=0; i<list.length; i++) {
			// Set up JSONP callback
			var engine=r.engines[i];
			engine.requestJSONP=function(url) {
				var script = document.createElement('script');
				script.src = url+r.name+".gotRoute"+this.subscript;
				document.body.appendChild(script); 
			};
			r['gotRoute'+i]=function(data) { engine.gotRoute(r,data); };
			select.append("<option value='"+i+"'>"+engine.name+"</option>");
		}
		r.chosenEngine=r.engines[0];
	};
	// Choose an engine on dropdown change
	r.selectEngine=function(e) {
		r.chosenEngine=r.engines[e.target.selectedIndex];
	};
	// Choose an engine by name
	r.chooseEngine=function(name) {
		for (var i=0; i<r.engines.length; i++) {
			if (r.engines[i].name==name) {
				r.chosenEngine[i]=r.engines[i];
				r.jqSearch.find('select.routing_engines').val(i);
			}
		}
	};

	return r;
};
